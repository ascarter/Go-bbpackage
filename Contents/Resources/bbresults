#!/usr/bin/env ruby

require 'optparse'

# Show results browser with each entry on stdin
#
# Format:
#   [error|warning|note]:[path]:[line]:(col): [msg]

class Entry
  attr_reader :kind, :file, :line, :column, :message
  
  def initialize(kind="error", file=nil, line = nil, column = nil, message = "")
    @kind = kind
    @file = file
    @line = line
    @column = column
    @message = message
  end
    
  def to_s()
    return "{result_kind:#{@kind}_kind, result_file:POSIX file \"#{@file}\", result_line:#{@line}, message: \"#{@message}\"}"
  end
  
  # id is a form of a key that disregards kind so that uniq can be used to filter
  def id()
    return "#{@file}:#{@line}:#{@message}"
  end
end

def parse(cwd, line)
  m = /^((\w+?)[:])?(\S+?)[:](\d+?)([:](\d+))?[:]\s+?(.*)$/.match(line)
  return nil if m.nil?
  
  # kind
  kind = ["error", "warning", "note"].include?(m[2]) ? m[2] : "error"
  
  # file
  filename = m[3].sub(/^[.][\/]/,"")
  filename.prepend("#{cwd}/") if not filename.start_with?("/")
  file = File.expand_path(filename)
  return nil if !File.file?(file)
  
  # line, column
  line =  m[4].nil? ? m[4].to_i : 0
  column = m[6].nil? ? m[6].to_i : 0
  
  # message
  message = m[7].strip unless m[7].nil?
  
  #STDERR.puts "kind='#{kind}' file='#{file}' line='#{line}' column='#{column}' message='#{message}'"  
  return Entry.new(kind, file, line, column, message)
end

def showResults(title, entries)  
  return if entries.length == 0  
  script = "tell application \"BBEdit\"\nmake new results browser with data {#{entries.join(",")}} with properties {name:\"#{title}\"}\nactivate\nend tell"
  IO.popen("osascript -l AppleScript - <<SCRIPT\n#{script}\nSCRIPT")
end

# Read options
options = {
  :title => "Results",
  :cwd => Dir.pwd 
}

opt_parser = OptionParser.new do |opts|
  opts.banner = "Usage: bbresults [options]"
  opts.separator ""
  opts.on("-t", "--title TITLE", "Set title") do |t|
    options[:title] = t
  end
  opts.on("-d", "--dir DIR", "Set working directory") do |d|
    options[:cwd] = File.expand_path(d)
  end
  opts.separator ""
  opts.separator "Input on STDIN in following format for each entry:"
  opts.separator "\t(error|warning|note):[path]:[line]:(col): [msg]"
end
opt_parser.parse!

# Get document root
if ENV.include?("BB_DOC_PATH")
  # Set working directory to doc path directory
  options[:cwd] = File.dirname(ENV["BB_DOC_PATH"])
end

# Read entries from stdin
entries = []
STDIN.readlines.each do |line|
  entry = parse(options[:cwd], line)
  entries.push entry unless entry.nil?
end

# Sort and filter entries
entries.sort_by! { |e| [e.file, e.line, e.message] }
entries.uniq! { |e| e.id }

# Display results browser
showResults(options[:title], entries)
