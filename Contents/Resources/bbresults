#!/usr/bin/env ruby

require 'optparse'

# Show results browser with each entry on stdin
#
# Format:
#   [error|warning|note]:[path]:[line]:(col): [msg]

class Entry
  attr_reader :kind, :file, :line, :column, :message
  
  def initialize(kind="error", file=nil, line = nil, column = nil, message = "")
    @kind = kind
    @file = file
    @line = line
    @column = column
    @message = message
  end
  
  # Parse result line
  def parse(cwd, line) 
    parts = line.split(":", 2)
    return false if parts.length < 2
      
    # Set result kind
    if ["error", "warning", "note"].include?(parts[0])
      @kind = parts[0]
      parts = parts[1].split(":", 2)
      return false if parts.length < 2
    end
    
    # Set file path
    filename = parts[0].sub(/^[.][\/]/,"")
    filename.prepend("#{cwd}/") if not filename.start_with?("/")
    @file = File.expand_path(filename)
    return false if !File.file?(@file)
    
    # Set line and column
    parts = parts[1].split(":", 2)
    return false if parts.length < 2
    
    @line = parts[0].to_i
    parts = parts[1].split(":", 2)
    if parts.length == 2
      @column = parts.shift.to_i
    end
    
    # Set message
    @message = parts.shift.strip()
    return true
  end
  
  def to_s()
    return "{result_kind:#{@kind}_kind, result_file:POSIX file \"#{@file}\", result_line:#{@line}, message: \"#{@message}\"}"
  end
  
  # id is a form of a key that disregards kind so that uniq can be used to filter
  def id()
    return "#{@file}:#{@line}:#{@message}"
  end
end

def showResults(title, entries)  
  return if entries.length == 0  
  script = "tell application \"BBEdit\"\nmake new results browser with data {#{entries.join(",")}} with properties {name:\"#{title}\"}\nactivate\nend tell"
  IO.popen("osascript -l AppleScript -e '#{script}'")
end

# Read options
options = {
  :title => "Results",
  :cwd => Dir.pwd 
}

opt_parser = OptionParser.new do |opts|
  opts.banner = "Usage: bbresults [options]"
  opts.separator ""
  opts.on("-t", "--title TITLE", "Set title") do |t|
    options[:title] = t
  end
  opts.on("-d", "--dir DIR", "Set working directory") do |d|
    options[:cwd] = File.expand_path(d)
  end
  opts.separator ""
  opts.separator "Input on STDIN in following format for each entry:"
  opts.separator "\t(error|warning|note):[path]:[line]:(col): [msg]"
end
opt_parser.parse!

# Get document root
if ENV.include?("BB_DOC_PATH")
  # Set working directory to doc path directory
  options[:cwd] = File.dirname(ENV["BB_DOC_PATH"])
end

# Read entries from stdin
entries = []
STDIN.readlines.each do |line|
  entry = Entry.new()
  if entry.parse(options[:cwd], line)
    entries.push entry
  end
end

# Sort and filter entries
entries.sort_by! { |e| [e.file, e.line, e.message] }
entries.uniq! { |e| e.id }

# Display results browser
showResults(options[:title], entries)
