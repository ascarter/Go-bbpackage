#!/usr/bin/env ruby

require 'optparse'

# Show results browser for each entry on stdin
# Format:
#   [error|warning|note]:[path]:[line]:[col]: [msg]

class Entry
  attr_reader :kind, :file, :line, :column, :message
  
  def initialize(kind="error", file=nil, line = nil, column = nil, message = "")
    @kind = kind
    @file = file
    @line = line
    @column = column
    @message = message
  end
  
  # Parse result line
  def parse(cwd, line)   
    parts = line.split(":")
    return false if parts.length < 4
    
    # Set result kind
    @kind = parts.shift
    return false if not ["error", "warning", "note"].include?(@kind)
    
    # Set file path
    filename = parts.shift.sub(/^[.][\/]/,"")
    filename.prepend("#{cwd}/") if not filename.start_with?("/")
    @file = File.expand_path(filename)
    return false if !File.file?(@file)
    
    # Set line and column
    if parts.length == 2
      @line = parts.shift.to_i
    else
      @line = parts.shift.to_i
      @column = parts.shift.to_i
    end
    
    # Set message
    @message = parts.shift.strip()
    
    return true
  end
  
  def to_s()
    return "{result_kind:#{@kind}_kind, result_file:POSIX file \"#{@file}\", result_line:#{@line}, message: \"#{@message}\"}"
  end
  
  # id is a form of a key that disregards kind so that uniq can be used to filter
  def id()
    return "#{@file}:#{@line}:#{@message}"
  end
end

def showResults(title, entries)  
  return if entries.length == 0  
  script = "tell me to tell application \"BBEdit\" to make new results browser with data {#{entries.join(",")}} with properties {name:\"#{title}\"}"
  IO.popen("osascript -l AppleScript -e '#{script}'")
end

# Read options
options = {
  :title => "goresults",
  :cwd => Dir.pwd 
}

opt_parser = OptionParser.new do |opts|
  opts.banner = "Usage: goresults [options]"
  opts.separator ""
  opts.on("-t", "--title TITLE", "Set title") do |t|
    options[:title] = t
  end
  opts.on("-d", "--dir DIR", "Set working directory") do |d|
    options[:cwd] = File.expand_path(d)
  end
end
opt_parser.parse!

# Get document root
if ENV.include?("BB_DOC_PATH")
  # Set working directory to doc path directory
  options[:cwd] = File.dirname(ENV["BB_DOC_PATH"])
end

# Read entries from stdin
entries = []
STDIN.readlines.each do |line|
  entry = Entry.new()
  if entry.parse(options[:cwd], line)
    entries.push entry
  end
end

# Sort and filter entries
entries.sort_by! { |e| [e.file, e.line, e.message] }
entries.uniq! { |e| e.id }

# Display results browser
showResults(options[:title], entries)
